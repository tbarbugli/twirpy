package generator

import "text/template"

type TwirpTemplateVariables struct {
	FileName string
	Services []*TwirpService
}

type TwirpService struct {
	ServiceURL string
	Name       string
	Comment    string
	Methods    []*TwirpMethod
}

type TwirpMethod struct {
	ServiceURL  string
	ServiceName string
	Name        string
	Comment     string
	Input       string
	Output      string
}

type TwirpImport struct {
	From   string
	Import string
}

// TwirpTemplate - Template for twirp server and client
var TwirpTemplate = template.Must(template.New("TwirpTemplate").Parse(`# -*- coding: utf-8 -*-
# Generated by https://github.com/verloop/twirpy/protoc-gen-twirpy.  DO NOT EDIT!
# source: {{.FileName}}

import asyncio
import aiohttp
import json

from google.protobuf import symbol_database as _symbol_database

from twirp.base import Endpoint
from twirp.server import TwirpServer
from twirp.client import TwirpClient
from typing import Optional

from twirp import exceptions
from twirp import errors

from urllib.parse import urljoin

_sym_db = _symbol_database.Default()
{{range .Services}}
class {{.Name}}Server(TwirpServer):

	def __init__(self, *args, service, server_path_prefix="/twirp"):
		super().__init__(service=service)
		self._prefix = F"{server_path_prefix}/{{.ServiceURL}}"
		self._endpoints = { {{- range .Methods }}
			"{{.Name}}": Endpoint(
				service_name="{{.ServiceName}}",
				name="{{.Name}}",
				function=getattr(service, "{{.Name}}"),
				input=_sym_db.GetSymbol("{{.Input}}"),
				output=_sym_db.GetSymbol("{{.Output}}"),
			),{{- end }}
		}

class {{.Name}}Client(TwirpClient):
{{range .Methods}}
	def {{.Name}}(self, *args, ctx, request, server_path_prefix="/twirp", **kwargs):
		return self._make_request(
			url=F"{server_path_prefix}/{{.ServiceURL}}/{{.Name}}",
			ctx=ctx,
			request=request,
			response_obj=_sym_db.GetSymbol("{{.Output}}"),
			**kwargs,
		)
{{end}}

class AsyncTwirpClient:
    def __init__(
        self, address: str, session: Optional[aiohttp.ClientSession] = None
    ) -> None:
        # Ensure address ends with a slash for urljoin to work correctly
        if not address.endswith("/"):
            address += "/"
        self._address = address
        self._session = session

    async def _make_request(
        self, *, url, ctx, request, response_obj, session=None, **kwargs
    ):
        headers = ctx.get_headers()
        if "headers" in kwargs:
            headers.update(kwargs["headers"])
        kwargs["headers"] = headers
        kwargs["headers"]["Content-Type"] = "application/protobuf"

        if session is None:
            session = self._session

        _session_created = False
        if not isinstance(session, aiohttp.ClientSession):
            session = aiohttp.ClientSession()
            _session_created = True

        # Construct the full URL by joining the base address and the path
        # Remove leading slash from url path if present, as self._address ends with /
        full_url = urljoin(self._address, url.lstrip("/"))

        try:
            # Use the correctly constructed full_url
            async with await session.post(
                url=full_url, data=request.SerializeToString(), **kwargs
            ) as resp:
                if resp.status == 200:
                    response = response_obj()
                    response.ParseFromString(await resp.read())
                    return response
                try:
                    raise exceptions.TwirpServerException.from_json(await resp.json())
                except (aiohttp.ContentTypeError, json.JSONDecodeError):
                    raise exceptions.twirp_error_from_intermediary(
                        resp.status, resp.reason, resp.headers, await resp.text()
                    ) from None
        except asyncio.TimeoutError as e:
            raise exceptions.TwirpServerException(
                code=errors.Errors.DeadlineExceeded,
                message=str(e) or "request timeout",
                meta={"original_exception": e},
            )
        except aiohttp.ServerConnectionError as e:
            # This catches more connection-related errors like ClientConnectorError
            raise exceptions.TwirpServerException(
                code=errors.Errors.Unavailable,
                message=str(e),
                meta={"original_exception": e},
            )
        finally:
            # Close the session only if we created it internally
            if _session_created and session:
                await session.close()

class Async{{.Name}}Client(AsyncTwirpClient):
{{range .Methods}}
    async def {{.Name}}(self, *, ctx, request, server_path_prefix="/twirp", session=None, **kwargs):
        return await self._make_request(
            url=F"{server_path_prefix}/{{.ServiceURL}}/{{.Name}}",
            ctx=ctx,
            request=request,
            response_obj=_sym_db.GetSymbol("{{.Output}}"),
            session=session,
            **kwargs,
        )
{{end}}{{end}}`))
